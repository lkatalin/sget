use serde_json::Value;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_plain::{derive_display_from_serialize, derive_fromstr_from_deserialize};
use std::collections::HashMap;
use std::num::NonZeroU64;
use x509_parser::{
    pem::parse_x509_pem, parse_x509_certificate
};
use ecdsa::{Signature as OtherSignature, VerifyingKey};
use p256::pkcs8::FromPublicKey;
use anyhow::{anyhow, Result};
use ecdsa::signature::Verifier;

// A signed root policy object
#[derive(Serialize, Deserialize)]
pub struct Policy {
    // A list of signatures.
    pub signatures: Vec<Signature>,
    // The root policy that is signed.
    pub signed: Root,
}

// A signature and the key ID and certificate that made it.
#[derive(Serialize, Deserialize)]
pub struct Signature {
    // The hex encoded key ID that made this signature.
    pub keyid: String,
    // The base64 encoded signature of the canonical JSON of the root policy.
    pub sig: String,
    // The base64 encoded certificate that was used to create the signature.
    pub cert: String,
}

// The root policy indicated the trusted root keys.
#[derive(Serialize, Deserialize, Debug)]
pub struct Root {
    pub spec_version: String,
    pub version: NonZeroU64,
    pub namespace: String,
    pub expires: DateTime<Utc>,
    pub consistent_snapshot: bool,
    // TODO: better define RoleType, right now it doesn't match the actual data
    // The uncommended code will compile, but the unit test will fail because of the above
    //pub roles: HashMap<RoleType, RoleKeys>,
    pub keys: HashMap<String, Key>,
}

#[derive(Serialize, Deserialize)]
pub struct RoleKeys {
    /// The key IDs used for the role.
    pub keyids: Vec<String>,
    /// The threshold of signatures required to validate the role.
    pub threshold: NonZeroU64,
}

#[derive(PartialEq, Eq, Hash, Serialize, Deserialize)]
/// The type of metadata role.
pub enum RoleType {
    /// The root role delegates trust to specific keys trusted for all other top-level roles used in
    /// the system.
    Root,
}

derive_display_from_serialize!(RoleType);
derive_fromstr_from_deserialize!(RoleType);

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "keytype")]
pub enum Key {
    /// A sigstore oidc key.
    #[serde(rename = "sigstore-oidc")]
    SigstoreOidc {
        /// The sigstore oidc key.
        keyval: SigstoreOidcKey,
        /// Denotes the key's scheme
        scheme: String,
        /// Any additional fields read during deserialization; will not be used.
        // TODO: key_hash_algorithms
        #[serde(flatten)]
        _extra: HashMap<String, Value>,
    },
}

derive_display_from_serialize!(Key);
derive_fromstr_from_deserialize!(Key);

#[derive(Serialize, Deserialize, Debug)]
/// Represents a deserialized (decoded) SigstoreOidc public key.
pub struct SigstoreOidcKey {
    /// The identity (subject)
    pub identity: String,
    /// The issuer
    pub issuer: String,
}

fn validate_expires(policy: Policy) -> chrono::Duration {
  let expiry = policy.signed.expires;
  let current = Utc::now();
  return expiry.signed_duration_since(current);
}

pub(crate) type CosignVerificationKey = VerifyingKey<p256::NistP256>;

/// Verify the signature provided has been actually generated by the given key against the
/// when signing the provided message.
pub(crate) fn verify_signature(
    verification_key: &CosignVerificationKey,
    signature_str: &str,
    msg: &[u8],
) -> Result<()> {
    let signature_raw = base64::decode(signature_str)?;
    let signature = OtherSignature::<p256::NistP256>::from_der(&signature_raw)?;
    verification_key
        .verify(msg, &signature)
        .map_err(|e| anyhow!("Verification failed: {:?}", e))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_script_success() {
        let mut fixture = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        fixture.push("tests/test_data/policy_good.json");
        let raw_json = std::fs::read(fixture).expect("Cannot read test file");

        let policy: Policy = serde_json::from_slice(&raw_json).expect("Cannot deserialize Policy");
        assert_eq!(policy.signed.version, NonZeroU64::new(1).unwrap())
    }
  
    #[test]
    fn validate_expiry_success() {
        let mut fixture = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        fixture.push("tests/test_data/policy_good.json");
        let raw_json = std::fs::read(fixture).expect("Cannot read test file");
        let policy: Policy = serde_json::from_slice(&raw_json).expect("Cannot deserialize Policy");
      
        let duration = validate_expires(policy);
        assert_eq!(duration.to_std().is_err(), false);
    }
  
    #[test]
    fn validate_expiry_failure() {
        let mut fixture = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        fixture.push("tests/test_data/policy_bad.json");
        let raw_json = std::fs::read(fixture).expect("Cannot read test file");
        let policy: Policy = serde_json::from_slice(&raw_json).expect("Cannot deserialize Policy");
      
        let duration = validate_expires(policy);
        assert_eq!(duration.to_std().is_err(), true);
    }

    #[test]
    fn parse_cert_success() {
        let mut fixture = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        fixture.push("tests/test_data/policy_good.json");
        let raw_json = std::fs::read(fixture).expect("Cannot read test file");
        let policy: Policy = serde_json::from_slice(&raw_json).expect("Cannot deserialize Policy");
        let cert_64 = &policy.signatures[0].cert;
        let cert = base64::decode(cert_64).unwrap();
        let (_, pem) = parse_x509_pem(&cert)
        .map_err(|e| anyhow!("Error parsing fulcio PEM certificate: {:?}", e)).unwrap();
        let (_, res_x509) = parse_x509_certificate(&pem.contents)
        .map_err(|e| anyhow!("Error parsing fulcio certificate: {:?}", e)).unwrap();
        let pub_key_bytes = res_x509.public_key().raw.to_owned();
        let pub_key = VerifyingKey::<p256::NistP256>::from_public_key_der(&pub_key_bytes[..]).map_err(|e| anyhow!("Cannot load key: {:?}", e));
        let signature = &policy.signatures[0].sig;
        let msg = 
        r#"{
            "_type": "root",
            "consistent_snapshot": true,
            "expires": "2022-01-08T15:33:26Z",
            "keys": {
              "5cc3f87d85b1a8f9ec3a4f4e552af9d6926381f87774b4a098cc4dd10498634c": {
                "keyid_hash_algorithms": [
                  "sha256",
                  "sha512"
                ],
                "keytype": "sigstore-oidc",
                "keyval": {
                  "identity": "lhinds@redhat.com",
                  "issuer": ""
                },
                "scheme": "https://fulcio.sigstore.dev"
              },
              "a27a1b676cce5db68748c1a34f3456edb7c800fc8a7a3303330b413ce2cb4e3e": {
                "keyid_hash_algorithms": [
                  "sha256",
                  "sha512"
                ],
                "keytype": "sigstore-oidc",
                "keyval": {
                  "identity": "kim@example.com",
                  "issuer": ""
                },
                "scheme": "https://fulcio.sigstore.dev"
              }
            },
            "namespace": "ghcr.io/lukehinds/cosign123",
            "roles": {
              "root": {
                "keyids": [
                  "5cc3f87d85b1a8f9ec3a4f4e552af9d6926381f87774b4a098cc4dd10498634c",
                  "a27a1b676cce5db68748c1a34f3456edb7c800fc8a7a3303330b413ce2cb4e3e"
                ],
                "threshold": 2
              }
            },
            "spec_version": "1.0",
            "version": 1
          }"#;

        let outcome = verify_signature(&pub_key.unwrap(),&signature,&msg.as_bytes());
        //let outcome = verify_signature(&pub_key.unwrap(),&signature,serde_json::to_string(&policy.signed).unwrap().as_bytes());
        assert!(outcome.is_ok());
        //assert_eq!(1,1);
    }
}